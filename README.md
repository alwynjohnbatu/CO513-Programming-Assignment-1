                                                                        Insights and Challenges in the ARM Assembly Programming Assignment

    Working through the ARM assembly problems—from factorial calculation to finding the maximum value in an array—offered valuable insight into how low-level programming directly manipulates registers and memory. Each task deepened my understanding of data movement, looping, and logical operations at the instruction level.
    
    One major insight I gained was how different ARM instructions cooperate to perform operations that are single-line statements in high-level languages (like Python and MATLAB). For example, implementing a factorial in this language required explicit control over loops and registers to manage multiplication and decrements, whereas in the higher-level languages, performing similar processes are already built in – I just need to directly insert a certain function or symbol to get the desired result. Similarly, finding the maximum in an array involved a lot of processes and emphasized pointer arithmetic and careful register handling.
    
    There were also several challenges. I often found it difficult to visualize how data flows between registers and how branching instructions (like BNE or BEQ) control program flow. At times, I find myself especially confused as to how the logic would work to solve each problem. I struggled to grasp how the logic translated from mathematical equations into assembly—especially in problems like the GCD (Euclidean algorithm), where the repeated subtraction or modulo logic can be tricky to trace without understanding conditional branching deeply.
    
    Another point of confusion arose in handling bitwise operations. For instance, in the parity checker problem, it took me some time to understand how it is possible to know if a binary number is of odd or even parity just by tracking a bit (LSB) using the logical operation Exclusive OR. Also, in the swapping nibbles problem, it also took me some time to understand how masking (AND) and shifting (LSR, LSL) work together to isolate and rearrange bits properly. Gradually, I learned that assembly programming demands careful step-by-step thinking—each instruction must explicitly perform what a single high-level statement would otherwise hide.
    
    In summary, this assignment improved my logical reasoning and further sharpened my thought process in handling multiple-step processes, as I needed to deeply understand first the logic of the process and break down many large processes into simpler ones to be able to convert them to codes. Furthermore, it also provided me with deeper understanding of register operations, control flow, and bit manipulation. The main challenge was bridging the gap between conceptual understanding and practical implementation, but working through confusion helped build a clearer grasp of how the ARM processor executes each operation at the hardware level.
